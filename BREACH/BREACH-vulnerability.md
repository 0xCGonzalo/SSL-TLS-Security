# SSL/TLS Security: BREACH

## Index:

* [Introduction](#introduction)
* [Compression Algorithms](#compression-algorithms)
* [Side Channel Compression Attacks](#side-channel-compression-attacks)
* [What is BREACH?](#What-is-BREACH)
* [Vulnerable Application: Necessary Conditions](#vulnerable-application-neccesary-conditions)
* [BREACH: Features](#BREACH-Features)
* [Mitigations](#mitigations)
* [References](#references)


### INTRODUCTION

To correctly define and understand the BREACH attack, it is necessary to have a basic understanding of compression side channel attacks and a clear understanding of compression algorithms.

### COMPRESSION ALGORITHMS

One of the most famous compression algorithms is DEFLATE, which defines the basis of the ZIP file format, the zlib library, gzip, PNGs, etc., and is made up of a combination of Huffman encoding and LZ77 compression.

In compression algorithms like DEFLATE, two approaches are used:

1. The most used letters get the shortest representation.
2. Any phrase that is repeated is only stored once.

Focusing on the second approach, if a certain string of characters is repeated somewhere in the text, it is only stored the first time along with pointers pointing to where the same sequence is found again. The second time it occurs, a reference to the first occurrence is included.

When a text appears several times, it is compressed very efficiently, since the number of bytes that are sent is less, so the size is smaller and the time required to send that data is also reduced.

Consider the following example:

```El insensato que reconoce su insensatez es un sabio. Pero el insensato que se cree un sabio es, en verdad, un insensato.```

As you can see, there are multiple words in the text that occur more than once. Gzip stores this by referencing a previous position when a repeated word or phrase is encountered.

  ![1](https://user-images.githubusercontent.com/43796175/106811742-c68afb00-663c-11eb-91b1-b494efccaa77.jpg)
<p align="center">Fig 1. “Compression using pointers to subsequent occurrences”</p>

Notice that the image shows the compressed file references. For example, the first blue dot in the sentence refers to an earlier use of "The fool who." This way, only 76 characters and 5 pointer references have to be stored, instead of the original 121 characters.

What should be noted here is that much of the text is the same, therefore the compressed size is smaller, and the compression is done very quickly. This feature can be used in a compression side channel attack.

### SIDE CHANNEL COMPRESSION ATTACKS

A side channel attack is an attack that uses information captured from a computer system implementation, rather than weaknesses in the implemented algorithm itself. It can be used to read confidential information, knowing only the size of the compressed data.

As explained above, compression works efficiently if a sentence appears multiple times in a text. This means that if a text contains both one part controlled by the user, and the other is a secret, we can guess the latter just by looking at the length of the compressed result.

For example, consider a website that uses compressed and encrypted cookies. Some of the cookie values ​​are secret and others can be set by the user. Because the cookie is encrypted, we cannot read the secret right away.

Suppose the plain text cookie looks like this:

<div style="text-align:center"><img src="https://user-images.githubusercontent.com/43796175/106812469-b9bad700-663d-11eb-8286-30738177c1fe.jpg"/></div>
<p align="center">Fig 2. “Cookie with a secret part and another controlled by the user”</p>

Note that the request accepts GZIP compression, DEFLATE in the "Accept-Encoding" attribute of the header. Additionally, users can set their favorite color, which leads to the question: What if a new favorite color is set equal to the secret?

<p align="center">![3](https://user-images.githubusercontent.com/43796175/106812812-2c2bb700-663e-11eb-9ee8-20d86877cab5.jpg)
<p align="center">Fig 3. “Réplica de atributos en cookie para ataque BREACH”</p>

Debido a que la frase “tops3cr3t” ahora aparece dos veces, la variable “Cookie” del encabezado se comprime de manera muy rápida y eficiente. Con solo mirar el tamaño de la cookie, que debería ser más pequeño que el tamaño cuando la variable toma el valor de “green”, se puede observar que el color “tops3cr3t” está presente en algún otro lugar de la cookie.
En la mayoría de los casos, incluso se puede adivinar un carácter a la vez. Simplemente se debería probar con "a", "b", “c”, etc. como el color favorito. Cuando el tamaño de la cookie se reduce en un byte, puede afirmarse con certeza que se ha adivinado correctamente el primer carácter.
Esto solo funciona si el secreto y los datos controlados por el atacante están comprimidos juntos, y podemos leer el tamaño de la respuesta después de la compresión.
Ahora bien, observe en la siguiente imagen que se realiza la búsqueda de la frase “Your secret code is: 1”, y el tamaño de la página de respuesta comprimida es de 355 bytes y restan 758 bytes sin comprimir:
NOTA: La frase “Your secret code is: 25bde29a” para este ejemplo en particular que no debería verse por el atacante, es una combinación de caracteres aleatorios, sin embargo podría ser cualquier tipo de información confidencial, como tarjeta de crédito, token de autorización, etc.
  
Fig 4. “Primera solicitud de ataque BREACH sin éxito”
Ahora bien, si se busca "Your secret code is: 2" se logra una compresión menor, debido a que coincide exactamente con el secreto:
  
Fig 5. “Segunda solicitud de ataque BREACH con éxito”
Entonces, si continúa la búsqueda "Your secret code is: 5", “Your secret code is: b”, etc., se obtendrá una compresión cada vez menor debido a que se adivina con éxito la frase secreta. Tenga en cuenta que el tamaño disminuye en un byte si adivinó un carácter correctamente. Dado que el mismo texto aparece dos veces, la página se comprime de forma más eficaz.
Por supuesto, en esta demostración, se puede ver explícitamente el atributo “secret”, pero el punto es que también puede determinarlo con solo mirar el tamaño de la página sin necesidad de conocerlo previamente.
Usted puede visitar el siguiente laboratorio de Sjoerd Langkember para comprobar lo que ha aprendido hasta el momento: http://demo.sjoerdlangkemper.nl/compression.php
Recapitulemos hasta este punto, un atacante puede leer información sensible, si y sólo si:
	Puede leer el tamaño de la página comprimida.
	Tiene control sobre algunos de los datos de esa página.
Ahora imagine que un atacante quiere obtener el token CSRF de un sitio web que se sirve a través de HTTPS, y se asume que el cibercriminal puede realizar solicitudes al sitio web, por ejemplo, inyectando etiquetas HTML o Javascript en otros sitios web (no HTTPS). Luego, el usuario malicioso no puede leer el resultado porque está cifrado, pero puede leer el tamaño de la respuesta. Si la página web también refleja parte de su entrada, puede atacar el sitio web mediante un ataque de canal lateral de compresión.
Luego, el atacante puede obtener un token CSRF realizando muchas solicitudes y observando el tamaño de la respuesta. Al igual que antes, sólo le restaría realizar solicitudes tales como "csrftoken=a", "csrftoken=b", etc. 
Para que funcione de manera efectiva, la página solicitada debe reflejar esta entrada y contener el token CSRF en sí.
Esta es la base de las vulnerabilidades CRIME y BREACH.

### WHAT IS BREACH?

En la Ekoparty 2012, Thai Duong y Juliano Rizzo anunciaron CRIME, un ataque de canal lateral de compresión contra HTTPS. 
La demostración particular dada en Ekoparty mostró cómo un atacante podría ejecutar este ataque para recuperar los encabezados de una solicitud HTTP. Dado que los encabezados HTTP contienen cookies y las cookies son el vehículo principal para la autenticación de aplicaciones web (después del inicio de sesión), esto presenta un ataque significativo.
Sin embargo, CRIME se mitigó por completo al inhabilitar la compresión TLS/SPDY y al modificar Gzip para permitir la separación explícita de contextos de compresión en SPDY. 
Los ataques BREACH, abreviatura de Browser Reconnaissance & Exfiltration via Adaptive Compression of Hypertext (Reconocimiento y Exfiltración del Navegador a través de la Compresión Adaptativa de Hipertexto), descubierto en 2013, son ataques similares al ataque CRIME.  Ambos ataques son ataques de canal lateral de compresión; sin embargo, CRIME apunta a la información comprimida en las solicitudes HTTP a través de la compresión TLS, mientras que BREACH apunta a la información comprimida en las respuestas HTTP a través de la compresión HTTP. Esto permite esencialmente el mismo ataque demostrado por Duong y Rizzo, pero sin depender de la compresión de nivel TLS.
A pesar de que el ataque BREACH no tiene como objetivo directo la seguridad SSL, pone en peligro el objetivo de privacidad de SSL al reducir HTTPS al cifrado de los encabezados de página, dejando otros contenidos susceptibles al descubrimiento. Mediante una combinación de ataques de fuerza bruta y técnicas de tipo "divide y vencerás", los piratas informáticos pueden utilizar los ataques BREACH para extraer credenciales de inicio de sesión, direcciones de correo electrónico y otros datos confidenciales de identificación personal de sitios web con SSL habilitado.
BREACH es una categoría de vulnerabilidades y no una instancia específica que afecta a un software específico. 

### VULNERABLE APPLICATION: NECCESARY CONDITIONS

Para ser vulnerable, una aplicación web debe:
	Ser atendida desde un servidor que utiliza compresión a nivel HTTP.
	Reflejar la entrada del usuario en los cuerpos de respuesta HTTP.
	Reflejar un secreto (como un token CSRF) en los cuerpos de respuesta HTTP.
Además, aunque no es estrictamente un requisito, el ataque se ve favorecido en gran medida por respuestas que siguen siendo en su mayoría las mismas. Esto se debe a que la diferencia en el tamaño de las respuestas medidas por el atacante pueden ser bastante pequeñas. Cualquier ruido en el canal lateral hace que el ataque sea más difícil (aunque no imposible).
También es importante mencionar que el ataque funciona contra cualquier conjunto de cifrado:
a.	Contra un cifrado de flujo, el ataque es más simple; la diferencia de tamaños entre los cuerpos de respuesta es mucho más granular en este caso. 
b.	Si se usa un cifrado de bloque, se debe realizar trabajo adicional para alinear la salida con los bloques de texto cifrado.

### BREACH: FEATURES
Las características fundamentales del ataque BREACH pueden agruparse en tres conceptos bien marcados:
	El ataque BREACH se puede explotar con miles de solicitudes y ejecutar en menos de un minuto.
	El número específico de solicitudes necesarias dependerá del tamaño del secreto. 
	El poder concreto del ataque proviene del hecho de que permite adivinar un carácter secreto por cada iteración, es decir, de uno en uno.

### MITIGACIÓN
Las mitigaciones están ordenadas por efectividad, no por su practicidad, ya que esto puede diferir de una aplicación a otra:
a.	Desactivar la compresión HTTP.
b.	Separar secretos de la entrada del usuario.
c.	Aleatorizar secretos por solicitud.
d.	Enmascarar secretos (aleatorización efectiva mediante XORing con un secreto aleatorio por solicitud).
e.	Aplicar protección a páginas vulnerables con CSRF.
f.	Ocultar la longitud agregando un número aleatorio de bytes a las respuestas.
g.	Limitar las solicitudes.
Independientemente de la mitigación que usted elija, se recomienda encarecidamente que también controle su tráfico para detectar intentos de ataque.

### REFERENCIAS
http://breachattack.com/
https://www.acunetix.com/blog/articles/breach-attack/
https://www.sjoerdlangkemper.nl/2016/08/23/compression-side-channel-attacks/
https://www.venafi.com/ 

