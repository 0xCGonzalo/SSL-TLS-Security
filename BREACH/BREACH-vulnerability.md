# SSL/TLS Security: BREACH

## Index:

* [Introduction](#introduction)
* [Compression Algorithms](#compression-algorithms)
* [Side Channel Compression Attacks](#side-channel-compression-attacks)
* [What is BREACH?](#What-is-BREACH)
* [Vulnerable Application: Necessary Conditions](#vulnerable-application-neccesary-conditions)
* [BREACH: Features](#BREACH-Features)
* [Mitigations](#mitigations)
* [References](#references)


### INTRODUCTION

To correctly define and understand the BREACH attack, it is necessary to have a basic understanding of compression side channel attacks and a clear understanding of compression algorithms.

### COMPRESSION ALGORITHMS

One of the most famous compression algorithms is DEFLATE, which defines the basis of the ZIP file format, the zlib library, gzip, PNGs, etc., and is made up of a combination of Huffman encoding and LZ77 compression.

In compression algorithms like DEFLATE, two approaches are used:

1. The most used letters get the shortest representation.
2. Any phrase that is repeated is only stored once.

Focusing on the second approach, if a certain string of characters is repeated somewhere in the text, it is only stored the first time along with pointers pointing to where the same sequence is found again. The second time it occurs, a reference to the first occurrence is included.

When a text appears several times, it is compressed very efficiently, since the number of bytes that are sent is less, so the size is smaller and the time required to send that data is also reduced.

Consider the following example:

```El insensato que reconoce su insensatez es un sabio. Pero el insensato que se cree un sabio es, en verdad, un insensato.```

As you can see, there are multiple words in the text that occur more than once. Gzip stores this by referencing a previous position when a repeated word or phrase is encountered.

  ![1](https://user-images.githubusercontent.com/43796175/106811742-c68afb00-663c-11eb-91b1-b494efccaa77.jpg)
<p align="center">Fig 1. “Compression using pointers to subsequent occurrences”</p>

Notice that the image shows the compressed file references. For example, the first blue dot in the sentence refers to an earlier use of "The fool who." This way, only 76 characters and 5 pointer references have to be stored, instead of the original 121 characters.

What should be noted here is that much of the text is the same, therefore the compressed size is smaller, and the compression is done very quickly. This feature can be used in a compression side channel attack.

### SIDE CHANNEL COMPRESSION ATTACKS

A side channel attack is an attack that uses information captured from a computer system implementation, rather than weaknesses in the implemented algorithm itself. It can be used to read confidential information, knowing only the size of the compressed data.

As explained above, compression works efficiently if a sentence appears multiple times in a text. This means that if a text contains both one part controlled by the user, and the other is a secret, we can guess the latter just by looking at the length of the compressed result.

For example, consider a website that uses compressed and encrypted cookies. Some of the cookie values ​​are secret and others can be set by the user. Because the cookie is encrypted, we cannot read the secret right away.

Suppose the plain text cookie looks like this:

<p align="center"><img src="https://user-images.githubusercontent.com/43796175/106812469-b9bad700-663d-11eb-8286-30738177c1fe.jpg"/></p>
<p align="center">Fig 2. “Cookie with a secret part and another controlled by the user”</p>

Note that the request accepts GZIP compression, DEFLATE in the "Accept-Encoding" attribute of the header. Additionally, users can set their favorite color, which leads to the question: What if a new favorite color is set equal to the secret?

<p align="center"><img src="https://user-images.githubusercontent.com/43796175/106812812-2c2bb700-663e-11eb-9ee8-20d86877cab5.jpg"></p>
<p align="center">Fig 3. “Attribute replication in cookie for BREACH attack”</p>

Because the phrase "**tops3cr3t**" now appears twice, the "Cookie" variable in the header is compressed very quickly and efficiently. Just looking at the size of the cookie, which should be smaller than the size when the variable takes the value of "**green**", you can see that the color "**tops3cr3t**" is present elsewhere in the cookie.

In most cases, you can even guess one character at a time. You should just try "**a**", "**b**", "**c**", etc. as the favorite color. When the size of the cookie is reduced by one byte, it can be said with certainty that the first character was correctly guessed.

This only works if the secret and the attacker-controlled data are compressed together, and we can read the response size after compression.

Now, notice in the following image that the search for the phrase “***Your secret code is: 1***” is performed, and the size of the compressed response page is 355 bytes and 758 uncompressed bytes remain:

*NOTE: The phrase "***Your secret code is: 25bde29a***" for this particular example that should not be seen by the attacker, is a combination of random characters, however it could be any type of confidential information, such as credit card, authorization token , etc.*

<p align="center"><img src="https://user-images.githubusercontent.com/43796175/106814570-99d8e280-6640-11eb-8d30-53b9e7d87ac8.jpg"></p>
<p align="center">Fig 4. “First unsuccessful BREACH attack request”</p>

Now, if you search for "***Your secret code is: 2***" a lower compression is achieved, because it exactly matches the secret:

<p align="center"><img src="https://user-images.githubusercontent.com/43796175/106814843-0227c400-6641-11eb-8454-2407f4124080.jpg"></p>
<p align="center">Fig 5. “Second successful BREACH attack request”</p>

So if you continue searching for "***Your secret code is: 5***", "***Your secret code is: b***", etc., you will get less and less compression due to successfully guess the secret phrase. Note that the size decreases by one byte if you guessed a character correctly. Since the same text appears twice, the page is compressed more efficiently.

Of course, in this demo, you can explicitly see the "secret" attribute, but the point is that you can also determine it just by looking at the page size without needing to know it first.

You can visit [Sjoerd Langkember's](https://www.linkedin.com/in/sjoerd-langkemper-86075246/) lab to see what he has learned so far: http://demo.sjoerdlangkemper.nl/compression.php

Let's recap up to this point, an attacker can read sensitive information, if:

1. He can read the size of the compressed page.
2. He have control over some of the data on that page.

Now imagine that an attacker wants to obtain the CSRF token from a website that is served over HTTPS, and it is assumed that the cybercriminal can make requests to the website, for example by injecting HTML or Javascript tags into other websites (not HTTPS ).

Then the malicious user cannot read the result because it is encrypted, but can read the size of the response. If the web page also reflects part of your input, it can attack the website using a compression side channel attack.

The attacker can then obtain a CSRF token by making many requests and observing the size of the response. As before, you only have to make requests such as "***csrftoken=a***", "***csrftoken=b***", etc.

For it to work effectively, the requested page must reflect this input and contain the CSRF token itself.

This is the basis for the CRIME and BREACH vulnerabilities.

### WHAT IS BREACH?

At Ekoparty 2012, Thai Duong and Juliano Rizzo announced CRIME, a compression side channel attack against HTTPS.

The particular demo given at Ekoparty showed how an attacker could execute this attack to retrieve the headers of an HTTP request. Since HTTP headers contain cookies and cookies are the primary vehicle for web application authentication (after login), this presents a significant attack.
However, CRIME was completely mitigated by disabling TLS / SPDY compression and modifying Gzip to allow explicit separation of compression contexts in SPDY.

The BREACH attacks, short for Browser Reconnaissance & Exfiltration via Adaptive Compression of Hypertext, discovered in 2013, are attacks similar to the CRIME attack. Both attacks are compression side channel attacks; however, CRIME targets information compressed in HTTP requests through TLS compression, while BREACH targets information compressed in HTTP responses through HTTP compression. This allows for essentially the same attack demonstrated by Duong and Rizzo, but without relying on TLS level compression.

Although the BREACH attack does not directly target SSL security, it jeopardizes the privacy objective of SSL by reducing HTTPS to the encryption of page headers, leaving other content susceptible to discovery. Using a combination of brute force attacks and "divide and conquer" techniques, hackers can use BREACH attacks to extract login credentials, email addresses, and other sensitive personally identifiable data from SSL-enabled websites. enabled.

BREACH is a category of vulnerabilities and not a specific instance that affects specific software.

### VULNERABLE APPLICATION: NECCESARY CONDITIONS

To be vulnerable, a web application must:

* Be served from a server that uses HTTP level compression.
* Reflect user input in HTTP response bodies.
* Reflect a secret (such as a CSRF token) in HTTP response bodies.

Also, while not strictly a requirement, the attack is largely aided by responses that remain mostly the same. This is because the difference in the size of the responses measured by the attacker can be quite small. Any noise in the side channel makes the attack more difficult (although not impossible).

It is also important to mention that the attack works against any cipher suite:

* Against a stream cipher, the attack is simpler; the difference in sizes between the response bodies is much more granular in this case.
* If block cipher is used, additional work must be done to align the output with the ciphertext blocks.

### BREACH: FEATURES

The fundamental characteristics of the BREACH attack can be grouped into three well-defined concepts:

1. The BREACH attack can be exploited with thousands of requests and executed in less than a minute.
2. The specific number of requests required will depend on the size of the secret.
3. The specific power of the attack comes from the fact that it allows a secret character to be guessed for each iteration, that is, one at a time.

### MITIGATIONS

The mitigations are ordered by effectiveness, not practicality, as this may differ from application to application:

1. Disable HTTP compression.
2. Separate secrets from user input.
3. Randomize secrets per request.
4. Masking secrets (effective randomization by XORing with one random secret per request).
5. Apply protection to vulnerable pages with CSRF.
6. Hide the length by adding a random number of bytes to the answers.
7. Limit requests.

Regardless of the mitigation you choose, it is strongly recommended that you also monitor your traffic for attempted attacks.

### REFERENCES

* http://breachattack.com/
* https://www.acunetix.com/blog/articles/breach-attack/
* https://www.sjoerdlangkemper.nl/2016/08/23/compression-side-channel-attacks/
* https://www.venafi.com/ 

